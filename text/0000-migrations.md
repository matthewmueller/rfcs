- Start Date: 2019-01-25
- RFC PR: (leave this empty)
- Prisma Issue: (leave this empty)

# Summary

One of the biggest USPs of the Prisma migration system is the automatic transition between two states of datamodels. However, for more advanced use-cases, especially when users are introducing breaking changes, we need to open up the migrations API, so that users can determin when and in which order migration steps as `createField` or `createType` are being executed.

The biggest difference is, that instead of taking the `datamodel.prisma` file as the source of  truth for the actual migration, it's just the source to create migration steps. The source of truth for migrations are the migration files that are being generated by the CLI.

While Prisma will provide a great migration experience, users still can always opt out of the Prisma migration system through running their own migrations, re-introspecting the database and updating the API exposed by the Prisma project.

# Basic example

# Motivation

# Detailed design

## Rough Commands (wording work in progress)

- `prisma migrate` Created migration files

- `prisma apply-migrations` Applies migrations in the database

- `prisma apply-datamodel` Only upate the API Schema, but not the underlying database

- `prisma deploy` Executes `prisma migrate` and `prisma apply-migrations`and `prisma apply-datamodel`

- `prisma dry-run` Executes the migrations in a dry-run

- `prisma cleanup` If migrations weren't successful, this can stop the migration running at  the moment and rollback it's effects

- `prisma baseline` This would introspect the database and add the introspection result to the Prisma Migration Table as a baseline for future deployments

  

The biggest question to answer for the migration system is this: Should users be able to opt in and opt out of the migration system or should it always be activated?

This proposal for now assumes, that the migration system is always opt in, as that is easier to reason about. However, we also present an alternative at the end of the design to provide opting in and out.



The new flow how migrations should work with Prisma is the following.

A user initiates a service with `prisma init` and ends up with a filesystem like this:

```
.
├── datamodel.prisma
└── prisma.yml
```

and a datamodel file like this:

```graphql
type User {
  id: ID! @id
  name: String!
}
```

The user then executes `prisma deploy`, which now creates a new migration file in the filesystem and applies that migration to the database:

```
.
├── datamodel.prisma
├── migrate
│   └── 0001_1548425145186.ts
└── prisma.yml
```

The content of `0001_1548425145186.ts` looks like this:

```ts
import { MigrationInterface, CreateModel } from 'prisma'

export default class Migration0001 implements MigrationInterface {
  operations = [
    CreateModel('User', p => {
      p.id('id')
      p.string('name')
    }),
  ]
}
```



Let's call the Prisma user Jen. Jen now pushes the project to Github and shares the project with her colleague Bob. The migration is now checked into version control.



## Filenames / Order of execution

Prisma would provide the opionation of calling migration files like this:

`VVVV_TIMESTAMP.ts`, where VVVV are 4 digits for the auto incrementing version and TIMESTAMP is a unix timestamp. The order in which Prisma reads the migration files is determined by a lexicographical ordering of the file names.

##  Scenario 1: Two compatible changes at the same time

Bob checks out the code locally and both Jen and Bob have a local version of Prisma running with their own database. Both Bob and Jen now perform a change to the datamodel, a local Migration file will be created and Jen pushes first. Bob doesn't pay too much attention what code Jen already pushed, just pulls and as he doesn't get any conflict, also pushes his code:

Jen's new `0002-1548425150000.ts`:

```ts
import { MigrationInterface, CreateField } from 'prisma'

export default class Migration0002 implements MigrationInterface {
  operations = [
    CreateField({
      model: 'User',
      name: 'address',
      type: 'String',
      isRequired: true,
      migrationValue: ''
    }),
  ]
}
```



Bob's new `0002-1548425140000.ts`

```ts
import { MigrationInterface, CreateField } from 'prisma'

export default class Migration0002 implements MigrationInterface {
  operations = [
    CreateField({
      model: 'User',
      name: 'age',
      type: 'Int',
      isRequired: true,
      migrationValue: -1
    }),
  ]
}
```



After the merge, the filesystem will look like this:

```
.
├── datamodel.prisma
├── migrate
│   ├── 0001_1548425145186.ts
│   ├── 0002-1548425140000.ts
│   └── 0002-1548425150000.ts
└── prisma.yml

```

The resulting datamodel will look like this:

```graphql
type User {
  id: ID! @id
  name: String!
  address: String!
  age: Int!
}
```

Prisma at this point should warn in a CI step, that two migrations have been created with the same version. But as these migrations are compatible, Prisma is able to merge them.



## Scenario 2: Two incompatible changes at the same time

Let's assume Jen now removes the `name` field from the `User` type, but Bob just wants to make it optional. This is a change that can't be solved automatically - we have a merge conflict.

The first barrier to prevent this from happening is a Git-based merge conflict in the `prisma.datamodel` file:

Jen's `datamodel.prisma` will look like this:

```graphql
type User {
  id: ID! @id
}
```

While Bob's `datamodel.prisma` will look like this:

```graphql
type User {
  id: ID @id
  name: String
}
```

The next barrier to catch this conflict is the actual Prisma migration system.

When the `prisma apply-migration` command is being executed in CI, it will read all migration files.

As soon as it will see the following two migrations, it will recognize a conflict:

Jen's migration file:

```ts
import { MigrationInterface, RemoveField } from 'prisma'

export default class Migration0002 implements MigrationInterface {
  operations = [
    RemoveField({
      model: 'User',
      name: 'name',
    }),
  ]
}
```

Bob's migration file:

```ts
import { MigrationInterface, UpdateField } from 'prisma'

export default class Migration0002 implements MigrationInterface {
  operations = [
    UpdateField({
      model: 'User',
      name: 'name',
      type: 'String',
      isRequired: false,
    }),
  ]
}
```

Prisma would fail in this case and ask for manual resolution from the user.

## Scenario 3:  Async  Workflows, migrating  data

In order to introduce a required field, that we need to initialize with proper data, we can provide a hook point for users to execute data transformations:

```ts
import { MigrationInterface, CreateField, UpdateField, RunAsync } from 'prisma'

export default class Migration0002 implements MigrationInterface {
  operations = [
    CreateField({
      model: 'User',
      name: 'address',
      type: 'String',
      isRequired: false,
    }),
    RunAsync(async client => {
      for (const user of client.users().$stream()) {
        await client.updateUser(user.id, {
          address: 'some default address in the universe ' + Math.random(),
        })
      }
    }),
    UpdateField({
      model: 'User',
      name: 'address',
      type: 'String',
      isRequired: true,
    }),
  ]
}
```

The client could potentially even be typed with the new field. Note, that this requires a temporary endpoint, which already includes the new field, even if the migration is not yet done.

## Scenario 4:  SQL / Database native code

To allow manipulating the underlying database directly, we provide a SQL interface:

```ts
import { MigrationInterface, RunSQL } from 'prisma'

export default class Migration0002 implements MigrationInterface {
  operations = [
    RunSQL(
      `CREATE TABLE X`,
      `DROP TABLE X`
    ), // with up and down
    RunSQL(
      `CREATE TABLE Y`,
    ), // with just up
  ]
}
```

## Scenario 5:  MongoDB access

The underlying MongoDB database could be manipulated like this:

```ts
import { MigrationInterface, RunMongo } from 'prisma'

export default class Migration0002 implements MigrationInterface {
  operations = [
    RunMongo(
      [{
        "createIndexes": "mycollection",
        "indexes": [
          {
            "key": {
              "username": 1,
              "created": -1
            },
            "name": "username_sort_by_asc_created",
            "background": true
          },
          {
            "key": {
              "email": 1
            },
            "name": "unique_email",
            "unique": true,
            "background": true
          }
        ]
      }],
      [
        {
          "dropIndexes": "mycollection",
          "index": "username_sort_by_asc_created"
        },
        {
          "dropIndexes": "mycollection",
          "index": "unique_email"
        }
      ]
    ), // with up and down
  ]
}
```



# Drawbacks

We could provide a completely free JavaScript API, without forcing the user to provide an array of operations. However, this wouldn't allow us to check migrations for validity upfront, so Prisma can't provide any guarantees and users would easily get into incosistent states with their database.

# Alternatives

# Adoption strategy

# How we teach this

# Unresolved questions

## How do we handle big migrations that need to scale over millions of table entries?

This would require a more sophisticated migration system, that uses data syncing with a Ghost table, as implemented by https://github.com/github/gh-ost.

A potential API to handle these "online" changes in a big production system could look like this:

```ts
import {
  MigrationInterface,
  CreateModel,
  RunAsync,
  CreateField,
  UpdateField,
} from 'prisma'

export default class Migration0002 implements MigrationInterface {
  operations = [
    CreateField({
      model: 'User',
      name: 'address',
      type: 'String',
      isRequired: true,
      migrationValue: '',
    }),
    RunAsync({
      watch: {
        BeforeUserCreated: user => {
          const [firstName, lastName] = user.name.split(' ')
          user.firstName = firstName
          user.last = lastName
          return user
        },
      },
      run: async client => {
        for await (const user of client.users().$stream()) {
          await client.updateUser(user.id, 'BeforeUserCreated')
        }
      },
    }),
    UpdateField({
      model: 'User',
      name: 'address',
      type: 'String',
      isRequired: true,
    }),
  ]
}

```



## Should we block the API during migration?

Systems like Rails follow this approach. This would make migrations easier to reason about and prevent inconsistent data state. For a big production application this would however not be acceptable.

